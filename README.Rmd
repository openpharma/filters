---
title: "filters"
output: github_document
---

```{r, include=FALSE}
knitr::opts_chunk$set(comment = "")
library(tibble)
```


`{filters}` is a "snake_case" filter system to `R`.


## Installation

```{r installation, eval=FALSE}
if (!requireNamespace("remotes")) {
  install.packages("remotes")
}
remotes::install_github(
  repo = "openpharma/filters",
  upgrade = "never"
)
```


## Features

```{r}
library(filters)
library(magrittr)
library(random.cdisc.data)
set.seed(1)
adsl <- radsl()
adae <- radae(adsl)
vads <- list(adsl = adsl, adae = adae)
```


### Built-In Filters

`{filters}` comes with a built-in filter library. You can list them using `list_all_filters()`.

```{r}
list_all_filters()
```


### Adding New Filters

To add a new filter use `add_filter()`. The last argument, `condition`, defines the condition to use to filter the datasets later on. It will be passed to `subset()` when calling `apply_filter()`.

```{r}
add_filter(
  id = "CTC34",
  title = "Grade 3-4 Adverse Events",
  target = "ADAE",
  condition = AETOXGR %in% c("4", "5")
)
```

Alternatively, you can use `load_filters()` to load filter definitions from a yaml file. The file should be structured like this:

```{yaml, eval=FALSE}
CTC4:
  title: Grade 4 Adverse Events
  target: ADAE
  condition: ATOXGR == "4"
TP53WT:
  title: TP53 Wild Type
  target: ADSL
  condition: TP53 == "WILD TYPE"
```

```{r}
file_path <- system.file("filters.yaml", package = "filters")
load_filters(file_path)
```

You can confirm that filters haven been successfully added by using `get_filter()`.

```{r}
get_filter("CTC34")
```

If you ask for a non-existing filter `get_filter()` will throw an error.

```{r, error=TRUE}
get_filter("GIDIS")
```

To overwrite an existing filter you will have to set `overwrite = TRUE`. Otherwise an error is thrown.

```{r, error=TRUE}
add_filter(
  id = "FATAL",
  title = "Fatal Adverse Events",
  target = "ADAE",
  condition = ATOXGR == "5"
)
add_filter(
  id = "FATAL",
  title = "Fatal Adverse Events",
  target = "ADAE",
  condition = ATOXGR == "5",
  overwrite = TRUE
)
```


### Applying Filters to Datasets

You can use `apply_filter()` to filter a single dataset or a `list` of multiple datasets.

```{r}
adsl_se <- apply_filter(adsl, "SE")
adae_ctc34_ser <- apply_filter(adae, "CTC34_SER")
filtered_datasets <- apply_filter(vads, "CTC34_SER_SE")
```

As you can see `apply_filter()` gives you feedback on which IDs matched the dataset. This matching is done by the name of the input dataset. It does not matter whether the dataset name is in upper or lower case or a mix of both.

```{r}
ADSL <- adsl
adsl_it <- apply_filter(ADSL, "IT")
```

In case your dataset is not named in a standard way you can manually tell `apply_filter()` which dataset it is by setting the `target` argument.

```{r}
sl <- adsl
sl_it1 <- apply_filter(sl, "IT")
sl_it2 <- apply_filter(sl, "IT", target = "ADSL")
```


### Using {filters} for Generating Outputs

`{filters}` package works well with `{rtables}` and `{tern}` packages. See the
following example of creating a table by a function:

```{r}
t_ae <- function(datasets) {
  anl <- merge(
    x = datasets$adsl,
    y = datasets$adae,
    by = c("STUDYID", "USUBJID"),
    all = FALSE, # inner join
    suffixes = c("", "_ADAE")
  )
  
  tern::t_events_per_term_id(
    terms = anl[, c("AEBODSYS", "AEDECOD")],
    id = anl$USUBJID,
    col_by = anl$ACTARM,
    col_N = table(datasets$adsl$ACTARM)
  )
}
```

You can easily create multiple outputs with this function by applying the filters to the input datasets *before* passing them to `t_ae()`. 

```{r}
vads %>% apply_filter("SE") %>% t_ae()
vads %>% apply_filter("SER_SE") %>% t_ae()
vads %>% apply_filter("CTC34_REL_SE") %>% t_ae()
```


## (Current) Limitations

The filters you created using `add_filter()` only persist for the duration of your `R` session. That means that whenever you restart your `R` session you will have to re-create them. The simplest way to do so is by putting all your filter definitions inside a file `filters.yml` file as described above and call `load_filters("path/to/filters.yml")` before creating outputs.

If you pass an existing filter that does not match your target dataset no warning or error is thrown. Instead `apply_filter()` only tells you which filters it actually used. Thus, checking that only valid filters are passed to `apply_filter()` is up to you.

```{r}
add_filter(
  id = "INFCT",
  title = "Infections and Infestations",
  target = "ADAE",
  condition = AEBODSYS == "INFECTIONS AND INFESTATIONS"
)
adsl_filtered <- apply_filter(adsl, "DIABP_IT")
```


## How Does it Work?

Internally, `{filters}` stores the filter definitions inside the `.filters` environment defined in `R/zzz.R`. When you add a filter with `add_filter()` a new variable with the name of the ID is created inside this environment. This variable is a list that stores the title, target and condition as a quoted expression. When you use `apply_filter()` the function looks for variables in `.filters` matching the provided suffixes. It then maps the filters to their target datasets and finally builds a call to `subset()` with the dataset as first and condition for the filters as second argument. This call is then evaluated using `eval()` and the result is returned.

